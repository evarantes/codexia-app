from fastapi import APIRouter, UploadFile, File, Form, HTTPException, BackgroundTasks
from typing import Optional, List
import shutil
import os
import json
import uuid
import requests
from pydantic import BaseModel
from app.services.book_assembler import BookAssembler
from app.services.ai_generator import AIContentGenerator
from app.database import get_db
from app.models import Book
from sqlalchemy.orm import Session
from fastapi import Depends
from docx import Document
from pypdf import PdfReader

router = APIRouter(prefix="/factory", tags=["Book Factory"])

# Temporary storage
UPLOAD_DIR = os.path.join("app", "static", "temp_uploads")
OUTPUT_DIR = os.path.join("app", "static", "generated")
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

class BookSectionConfig(BaseModel):
    title: str
    content: str
    included: bool = True

class BookGenerationRequest(BaseModel):
    metadata: dict
    sections: dict
    cover_filename: Optional[str] = None

@router.post("/upload")
async def upload_manuscript(
    file: UploadFile = File(...),
    cover: Optional[UploadFile] = File(None)
):
    """
    Receives the manuscript (DOCX/PDF) and optional cover.
    Analyzes text and returns a proposed structure.
    """
    file_path = os.path.join(UPLOAD_DIR, file.filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
        
    cover_path = None
    if cover:
        cover_path = os.path.join(UPLOAD_DIR, cover.filename)
        with open(cover_path, "wb") as buffer:
            shutil.copyfileobj(cover.file, buffer)

    # Extract text based on extension
    text_content = ""
    if file.filename.endswith(".docx"):
        doc = Document(file_path)
        text_content = "\n".join([p.text for p in doc.paragraphs])
    elif file.filename.endswith(".pdf"):
        reader = PdfReader(file_path)
        for page in reader.pages:
            text_content += page.extract_text() + "\n"
    else:
        # Fallback text
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            text_content = f.read()

    # AI Analysis
    ai_service = AIContentGenerator()
    structure_analysis = ai_service.analyze_manuscript_structure(text_content)
    
    detected_chapters = structure_analysis.get("chapters", [])
    
    # Helper to get detected content or generate suggestion
    def get_content(key, prompt_type):
        detected = structure_analysis.get(key)
        if detected and len(detected) > 10: # Simple check to avoid noise
            return detected
        return ai_service.generate_book_section(prompt_type, text_content, "Meu Livro")

    # Generate suggestions or use detected parts
    synopsis_suggestion = ai_service.generate_book_section("synopsis", text_content, "Meu Livro")
    
    # For these, we prefer extracted text
    epigraph_content = get_content("epigraph", "epigraph")
    preface_content = get_content("preface", "preface")
    dedication_content = get_content("dedication", "dedication")
    
    # These are usually not generated by AI if missing, but we pass them if found
    acknowledgments_content = structure_analysis.get("acknowledgments", "")
    intro_content = structure_analysis.get("introduction", "")

    return {
        "filename": file.filename,
        "cover_filename": cover.filename if cover else None,
        "detected_chapters": detected_chapters,
        "suggestions": {
            "synopsis": synopsis_suggestion,
            "epigraph": epigraph_content,
            "preface": preface_content,
            "dedication": dedication_content,
            "acknowledgments": acknowledgments_content,
            "introduction": intro_content
        },
        "raw_text_preview": text_content[:5000] # Limit for frontend
    }

@router.post("/upload_cover")
async def upload_cover(file: UploadFile = File(...)):
    """
    Uploads a cover image separately.
    """
    file_path = os.path.join(UPLOAD_DIR, file.filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    return {"filename": file.filename, "url": f"/static/temp_uploads/{file.filename}"} # Assuming we map temp_uploads later or move it

class RegenerationRequest(BaseModel):
    section_type: str
    context: str
    title: str = "Livro"

@router.post("/regenerate_section")
async def regenerate_section(request: RegenerationRequest):
    """
    Regenerates a specific section (epigraph, synopsis, preface) using AI.
    """
    ai_service = AIContentGenerator()
    content = ai_service.generate_book_section(request.section_type, request.context, request.title)
    return {"content": content}

class GenerateCoverRequest(BaseModel):
    title: str
    context: str
    author: Optional[str] = ""
    subtitle: Optional[str] = ""

@router.post("/generate_covers")
async def generate_covers(request: GenerateCoverRequest):
    ai_service = AIContentGenerator()
    urls = ai_service.generate_cover_options(request.title, request.context, request.author, request.subtitle)
    
    saved_urls = []
    # Ensure static/covers exists
    COVERS_DIR = os.path.join("app", "static", "covers")
    os.makedirs(COVERS_DIR, exist_ok=True)
    
    for url in urls:
        if url.startswith("http"):
            try:
                response = requests.get(url, stream=True)
                if response.status_code == 200:
                    filename = f"cover_{uuid.uuid4().hex}.png"
                    file_path = os.path.join(COVERS_DIR, filename)
                    with open(file_path, 'wb') as out_file:
                        shutil.copyfileobj(response.raw, out_file)
                    saved_urls.append(f"/static/covers/{filename}")
                else:
                    saved_urls.append(url)
            except Exception as e:
                print(f"Failed to download cover: {e}")
                saved_urls.append(url)
        else:
            saved_urls.append(url)
            
    return {"covers": saved_urls}

def resolve_cover_path(filename: str) -> Optional[str]:
    if not filename:
        return None
    
    # 1. Check in UPLOAD_DIR (Uploaded files)
    p1 = os.path.join(UPLOAD_DIR, os.path.basename(filename))
    if os.path.exists(p1):
        return p1
        
    # 2. Check in app/static (AI generated, passed as 'covers/xxx.png' or '/static/covers/xxx.png')
    # Remove '/static/' prefix if present
    clean_name = filename
    if clean_name.startswith("/static/"):
        clean_name = clean_name.replace("/static/", "", 1)
    
    p2 = os.path.join("app", "static", clean_name)
    if os.path.exists(p2):
        return p2
        
    return None

@router.post("/preview")
async def preview_book_pdf(request: BookGenerationRequest):
    """
    Generates a temporary PDF for preview.
    """
    preview_filename = f"preview_{request.metadata.get('title', 'book')}.pdf"
    output_path = os.path.join(OUTPUT_DIR, preview_filename)
    
    assembler = BookAssembler(output_path=output_path)
    
    book_data = {
        "metadata": request.metadata,
        "cover_image": resolve_cover_path(request.cover_filename),
        "sections": request.sections
    }
    
    # Generate
    try:
        assembler.create_book(book_data)
        return {"status": "success", "preview_url": f"/static/generated/{preview_filename}"}
    except Exception as e:
        print(f"Error generating preview: {e}")
        return {"status": "error", "detail": str(e)}

@router.post("/generate")
async def generate_book_pdf(request: BookGenerationRequest, db: Session = Depends(get_db)):
    """
    Generates the final PDF based on the user-approved structure.
    """
    assembler = BookAssembler(output_path=os.path.join(OUTPUT_DIR, f"{request.metadata.get('title', 'book')}.pdf"))
    
    # Reconstruct full data for assembler
    book_data = {
        "metadata": request.metadata,
        "cover_image": resolve_cover_path(request.cover_filename),
        "sections": request.sections
    }
    
    output_file = assembler.create_book(book_data)
    
    # Save to Database for "Meus Livros"
    try:
        new_book = Book(
            title=request.metadata.get('title', 'Sem TÃ­tulo'),
            author=request.metadata.get('author', 'Autor'),
            synopsis=request.sections.get('synopsis', ''),
            full_text=json.dumps(request.sections), # Storing sections as JSON in full_text for now
            price=29.90, # Default price
            payment_link="",
            cover_image_url=resolve_cover_path(request.cover_filename),
            file_path=f"/static/generated/{os.path.basename(output_file)}"
        )
        db.add(new_book)
        db.commit()
        db.refresh(new_book)
        print(f"Livro salvo no banco: {new_book.id}")
    except Exception as e:
        print(f"Erro ao salvar livro no banco: {e}")

    return {"status": "success", "download_url": f"/static/generated/{os.path.basename(output_file)}"}
