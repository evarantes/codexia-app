from fastapi import APIRouter, UploadFile, File, Form, HTTPException, BackgroundTasks
from typing import Optional, List
import shutil
import os
import json
import uuid
import requests
from pydantic import BaseModel
from app.services.book_assembler import BookAssembler
from app.services.ai_generator import AIContentGenerator
from app.database import get_db
from app.models import Book, BookDraft
from sqlalchemy.orm import Session
from fastapi import Depends
from docx import Document
from pypdf import PdfReader

router = APIRouter(prefix="/factory", tags=["Book Factory"])

# Temporary storage
UPLOAD_DIR = os.path.join("app", "static", "temp_uploads")
OUTPUT_DIR = os.path.join("app", "static", "generated")
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

class BookSectionConfig(BaseModel):
    title: str
    content: str
    included: bool = True

class BookGenerationRequest(BaseModel):
    metadata: dict
    sections: dict
    cover_filename: Optional[str] = None

@router.post("/upload-manuscript")
async def upload_manuscript(
    file: UploadFile = File(...),
    cover: Optional[UploadFile] = File(None)
):
    """
    Receives the manuscript (DOCX/PDF) and optional cover.
    Analyzes text and returns a proposed structure.
    """
    file_path = os.path.join(UPLOAD_DIR, file.filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
        
    cover_path = None
    if cover:
        cover_path = os.path.join(UPLOAD_DIR, cover.filename)
        with open(cover_path, "wb") as buffer:
            shutil.copyfileobj(cover.file, buffer)

    # Extract text based on extension
    text_content = ""
    if file.filename.endswith(".docx"):
        doc = Document(file_path)
        text_content = "\n".join([p.text for p in doc.paragraphs])
    elif file.filename.endswith(".pdf"):
        reader = PdfReader(file_path)
        for page in reader.pages:
            text_content += page.extract_text() + "\n"
    else:
        # Fallback text
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            text_content = f.read()

    # AI Analysis
    ai_service = AIContentGenerator()
    structure_analysis = ai_service.analyze_manuscript_structure(text_content)
    
    detected_chapters = structure_analysis.get("chapters", [])
    
    # Helper to get detected content or generate suggestion
    def get_content(key, prompt_type):
        detected = structure_analysis.get(key)
        if detected and len(detected) > 10: # Simple check to avoid noise
            return detected
        return ai_service.generate_book_section(prompt_type, text_content, "Meu Livro")

    # Generate suggestions or use detected parts
    synopsis_suggestion = ai_service.generate_book_section("synopsis", text_content, "Meu Livro")
    
    # For these, we prefer extracted text
    epigraph_content = get_content("epigraph", "epigraph")
    preface_content = get_content("preface", "preface")
    dedication_content = get_content("dedication", "dedication")
    
    # These are usually not generated by AI if missing, but we pass them if found
    acknowledgments_content = structure_analysis.get("acknowledgments", "")
    intro_content = structure_analysis.get("introduction", "")

    return {
        "filename": file.filename,
        "cover_filename": cover.filename if cover else None,
        "detected_chapters": detected_chapters,
        "suggestions": {
            "synopsis": synopsis_suggestion,
            "epigraph": epigraph_content,
            "preface": preface_content,
            "dedication": dedication_content,
            "acknowledgments": acknowledgments_content,
            "introduction": intro_content
        },
        "raw_text_preview": text_content[:5000] # Limit for frontend
    }

class CreateDraftRequest(BaseModel):
    title: str
    idea: str
    num_chapters: int
    num_pages: int = 50
    style: str = "didático"

@router.post("/create_draft")
async def create_draft(request: CreateDraftRequest):
    """
    Generates a full book structure from scratch using AI.
    """
    ai_service = AIContentGenerator()
    try:
        structure = ai_service.generate_full_book_draft(
            title=request.title,
            idea=request.idea,
            num_chapters=request.num_chapters,
            style=request.style,
            num_pages=request.num_pages
        )
        
        # Format response to match existing frontend expectations
        return {
            "filename": f"generated_{uuid.uuid4().hex[:8]}.txt",
            "cover_filename": structure.get("cover_url"), # Direct URL or None
            "detected_chapters": structure.get("chapters", []),
            "suggestions": {
                "synopsis": ai_service.generate_book_section("synopsis", request.idea, request.title),
                "epigraph": structure.get("epigraph", ""),
                "preface": structure.get("preface", ""),
                "dedication": structure.get("dedication", ""),
                "acknowledgments": structure.get("acknowledgments", ""),
                "introduction": structure.get("introduction", "")
            },
            "raw_text_preview": f"Livro gerado por IA: {request.title}\n\nIdeia: {request.idea}\n\nMeta de Páginas: {request.num_pages}"
        }
    except Exception as e:
        print(f"Error generating draft: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/upload-cover")
async def upload_cover(file: UploadFile = File(...)):
    """
    Uploads a cover image separately.
    """
    file_path = os.path.join(UPLOAD_DIR, file.filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    return {"filename": file.filename, "url": f"/static/temp_uploads/{file.filename}"} # Assuming we map temp_uploads later or move it

class RegenerationRequest(BaseModel):
    section_type: str
    context: str
    title: str = "Livro"

@router.post("/regenerate_section")
async def regenerate_section(request: RegenerationRequest):
    """
    Regenerates a specific section (epigraph, synopsis, preface) using AI.
    """
    ai_service = AIContentGenerator()
    content = ai_service.generate_book_section(request.section_type, request.context, request.title)
    return {"content": content}

class GenerateCoverRequest(BaseModel):
    title: str
    context: Optional[str] = None
    description: Optional[str] = None # Frontend sends 'description'
    author: Optional[str] = ""
    subtitle: Optional[str] = ""

@router.post("/generate-covers")
async def generate_covers(request: GenerateCoverRequest):
    context_text = request.context or request.description or "Livro sem descrição"
    saved_urls = []
    try:
        ai_service = AIContentGenerator()
        urls = ai_service.generate_cover_options(
            request.title, context_text,
            request.author or "", request.subtitle or ""
        )
        COVERS_DIR = os.path.join("app", "static", "covers")
        os.makedirs(COVERS_DIR, exist_ok=True)
        for url in (urls or []):
            if url and str(url).startswith("http"):
                try:
                    response = requests.get(url, stream=True, timeout=60)
                    if response.status_code == 200:
                        filename = f"cover_{uuid.uuid4().hex}.png"
                        file_path = os.path.join(COVERS_DIR, filename)
                        with open(file_path, "wb") as out_file:
                            shutil.copyfileobj(response.raw, out_file)
                        saved_urls.append(f"/static/covers/{filename}")
                    else:
                        saved_urls.append(url)
                except Exception as e:
                    print(f"Failed to download cover: {e}")
                    saved_urls.append(url)
            elif url:
                saved_urls.append(url)
    except Exception as e:
        print(f"generate-covers error: {e}")
    return {"covers": saved_urls}

def resolve_cover_path(filename: str) -> Optional[str]:
    if not filename:
        return None
    
    # 1. Check in UPLOAD_DIR (Uploaded files)
    p1 = os.path.join(UPLOAD_DIR, os.path.basename(filename))
    if os.path.exists(p1):
        return p1
        
    # 2. Check in app/static (AI generated, passed as 'covers/xxx.png' or '/static/covers/xxx.png')
    # Remove '/static/' prefix if present
    clean_name = filename
    if clean_name.startswith("/static/"):
        clean_name = clean_name.replace("/static/", "", 1)
    
    p2 = os.path.join("app", "static", clean_name)
    if os.path.exists(p2):
        return p2
        
    return None

@router.post("/revise")
async def revise_book(request: BookGenerationRequest):
    """
    Analyzes the current book structure and content, filling in missing parts
    (empty chapters, epilogues) without overwriting existing content.
    """
    ai_service = AIContentGenerator()
    
    # 1. Revise Textual Chapters
    chapters = request.sections.get('textual', [])
    updated_chapters = []
    
    for i, chapter in enumerate(chapters):
        content = chapter.get('content', '')
        title = chapter.get('title', f'Capítulo {i+1}')
        
        # If content is missing or too short (placeholder), generate it
        if len(content.strip()) < 50:
            print(f"Revising: Generating content for chapter '{title}'...")
            # Use the book title and idea/synopsis as context
            book_title = request.metadata.get('title', 'Livro')
            context = f"Livro: {book_title}. "
            if request.sections.get('pre_textual', {}).get('synopsis'):
                 context += f"Sinopse: {request.sections['pre_textual']['synopsis']}"
            
            # Generate chapter content
            # We reuse generate_book_section but we might need a more specific prompt for a chapter
            # Let's use a specialized method or reuse generate_book_section with clear instructions
            new_content = ai_service.generate_chapter_content(
                chapter_title=title,
                book_title=book_title,
                context=context,
                style=request.metadata.get('style', 'didático') # We might need to pass style in metadata
            )
            chapter['content'] = new_content
        
        updated_chapters.append(chapter)
    
    request.sections['textual'] = updated_chapters
    
    # 2. Revise Post-Textual (Epilogue)
    post_textual = request.sections.get('post_textual', {})
    if 'epilogue' in post_textual:
        # If epilogue is requested (present in keys) but empty
        if len(post_textual['epilogue'].strip()) < 50:
             print("Revising: Generating Epilogue...")
             book_title = request.metadata.get('title', 'Livro')
             context = f"Livro: {book_title}."
             new_epilogue = ai_service.generate_book_section("epilogue", context, book_title)
             post_textual['epilogue'] = new_epilogue

    return {
        "status": "success", 
        "sections": request.sections,
        "message": "Livro revisado e completado com sucesso!"
    }

@router.post("/generate-preview")
async def preview_book_pdf(request: BookGenerationRequest):
    """
    Generates a temporary PDF for preview.
    """
    preview_filename = f"preview_{request.metadata.get('title', 'book')}.pdf"
    output_path = os.path.join(OUTPUT_DIR, preview_filename)
    
    assembler = BookAssembler(output_path=output_path)
    
    book_data = {
        "metadata": request.metadata,
        "cover_image": resolve_cover_path(request.cover_filename),
        "sections": request.sections
    }
    
    # Generate
    try:
        assembler.create_book(book_data)
        return {"status": "success", "preview_url": f"/static/generated/{preview_filename}"}
    except Exception as e:
        print(f"Error generating preview: {e}")
        return {"status": "error", "detail": str(e)}

# ----- Rascunhos: salvar análise para editar depois e gerar ou excluir -----

class SaveDraftRequest(BaseModel):
    metadata: dict
    sections: dict
    cover_filename: Optional[str] = None
    manuscript_filename: Optional[str] = None

@router.post("/draft")
async def save_draft(request: SaveDraftRequest, db: Session = Depends(get_db)):
    """Salva a estrutura atual como rascunho para analisar/editar depois."""
    try:
        draft = BookDraft(
            title=request.metadata.get("title", "Sem Título"),
            author=request.metadata.get("author", ""),
            metadata_json=json.dumps(request.metadata, ensure_ascii=False),
            sections_json=json.dumps(request.sections, ensure_ascii=False),
            cover_filename=request.cover_filename,
            manuscript_filename=request.manuscript_filename,
        )
        db.add(draft)
        db.commit()
        db.refresh(draft)
        return {"id": draft.id, "title": draft.title, "message": "Rascunho salvo com sucesso."}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/drafts")
async def list_drafts(db: Session = Depends(get_db)):
    """Lista todos os rascunhos (mais recentes primeiro)."""
    drafts = db.query(BookDraft).order_by(BookDraft.updated_at.desc()).all()
    return [
        {
            "id": d.id,
            "title": d.title,
            "author": d.author,
            "cover_filename": d.cover_filename,
            "created_at": d.created_at.isoformat() if d.created_at else None,
            "updated_at": d.updated_at.isoformat() if d.updated_at else None,
        }
        for d in drafts
    ]

@router.get("/drafts/{draft_id}")
async def get_draft(draft_id: int, db: Session = Depends(get_db)):
    """Retorna um rascunho no formato usado pelo editor (metadata, sections, cover_filename)."""
    draft = db.query(BookDraft).filter(BookDraft.id == draft_id).first()
    if not draft:
        raise HTTPException(status_code=404, detail="Rascunho não encontrado.")
    metadata = json.loads(draft.metadata_json) if draft.metadata_json else {}
    sections = json.loads(draft.sections_json) if draft.sections_json else {}
    return {
        "metadata": metadata,
        "sections": sections,
        "cover_filename": draft.cover_filename,
        "manuscript_filename": draft.manuscript_filename,
    }

@router.put("/drafts/{draft_id}")
async def update_draft(draft_id: int, request: SaveDraftRequest, db: Session = Depends(get_db)):
    """Atualiza um rascunho existente."""
    draft = db.query(BookDraft).filter(BookDraft.id == draft_id).first()
    if not draft:
        raise HTTPException(status_code=404, detail="Rascunho não encontrado.")
    try:
        draft.title = request.metadata.get("title", draft.title)
        draft.author = request.metadata.get("author", draft.author)
        draft.metadata_json = json.dumps(request.metadata, ensure_ascii=False)
        draft.sections_json = json.dumps(request.sections, ensure_ascii=False)
        draft.cover_filename = request.cover_filename
        draft.manuscript_filename = request.manuscript_filename
        db.commit()
        db.refresh(draft)
        return {"id": draft.id, "title": draft.title, "message": "Rascunho atualizado."}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/drafts/{draft_id}/generate")
async def generate_from_draft(draft_id: int, db: Session = Depends(get_db)):
    """Gera o PDF a partir do rascunho, salva em Meus Livros e remove o rascunho."""
    draft = db.query(BookDraft).filter(BookDraft.id == draft_id).first()
    if not draft:
        raise HTTPException(status_code=404, detail="Rascunho não encontrado.")
    metadata = json.loads(draft.metadata_json) if draft.metadata_json else {}
    sections = json.loads(draft.sections_json) if draft.sections_json else {}
    cover_filename = draft.cover_filename

    assembler = BookAssembler(output_path=os.path.join(OUTPUT_DIR, f"{metadata.get('title', 'book')}.pdf"))
    book_data = {
        "metadata": metadata,
        "cover_image": resolve_cover_path(cover_filename),
        "sections": sections,
    }
    try:
        output_file = assembler.create_book(book_data)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao gerar PDF: {e}")

    try:
        new_book = Book(
            title=metadata.get("title", "Sem Título"),
            author=metadata.get("author", "Autor"),
            synopsis=sections.get("pre_textual", {}).get("synopsis", ""),
            full_text=json.dumps(sections),
            price=29.90,
            payment_link="",
            cover_image_url=resolve_cover_path(cover_filename),
            file_path=f"/static/generated/{os.path.basename(output_file)}",
        )
        db.add(new_book)
        db.commit()
        db.refresh(new_book)
    except Exception as e:
        print(f"Erro ao salvar livro no banco: {e}")

    db.delete(draft)
    db.commit()

    return {"status": "success", "pdf_url": f"/static/generated/{os.path.basename(output_file)}", "message": "Livro gerado e rascunho removido."}

@router.delete("/drafts/{draft_id}")
async def delete_draft(draft_id: int, db: Session = Depends(get_db)):
    """Exclui um rascunho."""
    draft = db.query(BookDraft).filter(BookDraft.id == draft_id).first()
    if not draft:
        raise HTTPException(status_code=404, detail="Rascunho não encontrado.")
    db.delete(draft)
    db.commit()
    return {"message": "Rascunho excluído."}


@router.post("/generate-pdf")
async def generate_book_pdf(request: BookGenerationRequest, db: Session = Depends(get_db)):
    """
    Generates the final PDF based on the user-approved structure.
    """
    assembler = BookAssembler(output_path=os.path.join(OUTPUT_DIR, f"{request.metadata.get('title', 'book')}.pdf"))
    
    # Reconstruct full data for assembler
    book_data = {
        "metadata": request.metadata,
        "cover_image": resolve_cover_path(request.cover_filename),
        "sections": request.sections
    }
    
    output_file = assembler.create_book(book_data)
    
    # Save to Database for "Meus Livros"
    try:
        new_book = Book(
            title=request.metadata.get('title', 'Sem Título'),
            author=request.metadata.get('author', 'Autor'),
            synopsis=request.sections.get('synopsis', ''),
            full_text=json.dumps(request.sections), # Storing sections as JSON in full_text for now
            price=29.90, # Default price
            payment_link="",
            cover_image_url=resolve_cover_path(request.cover_filename),
            file_path=f"/static/generated/{os.path.basename(output_file)}"
        )
        db.add(new_book)
        db.commit()
        db.refresh(new_book)
        print(f"Livro salvo no banco: {new_book.id}")
    except Exception as e:
        print(f"Erro ao salvar livro no banco: {e}")

    return {"status": "success", "pdf_url": f"/static/generated/{os.path.basename(output_file)}"}
